<!DOCTYPE html>
<html lang="en">
  <!-- Beautiful Jekyll | MIT license | Copyright Dean Attali 2016 -->
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover">

  <title>Deep Dream</title>

  <meta name="author" content="Sakshay Mahna" />

  

  <link rel="alternate" type="application/rss+xml" title="Progress Blog - -- JDE Robotics" href="/colab-Sakshay_Mahna/feed.xml" />

  

  

  


  
    
      
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.0/css/font-awesome.min.css" />


    
  

  
    
      <link rel="stylesheet" href="/colab-Sakshay_Mahna/css/bootstrap.min.css" />
    
      <link rel="stylesheet" href="/colab-Sakshay_Mahna/css/bootstrap-social.css" />
    
      <link rel="stylesheet" href="/colab-Sakshay_Mahna/css/main.css" />
    
  

  
    
      <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
    
      <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
    
  

  

  

  

    <!-- Facebook OpenGraph tags -->
  

  
  <meta property="og:title" content="Deep Dream" />
  

   
  <meta property="og:description" content="Deep Dream is a computer vision program, developed by Google engineer Alexander Mordvintsev that turns simple images into dream-like psychedelic image. The program uses CNNs behind the scenes to make this happen. This post discusses about this algorithm and its implementation. Let’s get high! Deep Dream Algorithm Convolutional Neural Networks...">
  


  <meta property="og:type" content="website" />

  
  <meta property="og:url" content="http://localhost:4000/2020-04-14-deep-dream/" />
  <link rel="canonical" href="http://localhost:4000/2020-04-14-deep-dream/" />
  

  
  <meta property="og:image" content="http://localhost:4000/img/logo.png" />
  


  <!-- Twitter summary cards -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <meta name="twitter:creator" content="@" />

  
  <meta name="twitter:title" content="Deep Dream" />
  

  
  <meta name="twitter:description" content="Deep Dream is a computer vision program, developed by Google engineer Alexander Mordvintsev that turns simple images into dream-like psychedelic image. The program uses CNNs behind the scenes to make this happen. This post discusses about this algorithm and its implementation. Let’s get high! Deep Dream Algorithm Convolutional Neural Networks...">
  

  
  <meta name="twitter:image" content="http://localhost:4000/img/logo.png" />
  

  

  

</head>


  <body>

    

  
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
        <a class="navbar-brand" href="http://localhost:4000">Progress Blog</a>
      
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
      
        
          <li>
            






<a href="/colab-Sakshay_Mahna/aboutme">About Me</a>

          </li>
        
        
      </ul>
    </div>

	
	<div class="avatar-container">
	  <div class="avatar-img-border">
	    <a href="http://localhost:4000">
	      <img class="avatar-img" src="/colab-Sakshay_Mahna/img/logo.png" />
		</a>
	  </div>
	</div>
	

  </div>
</nav>


    <!-- TODO this file has become a mess, refactor it -->





<header class="header-section ">

<div class="intro-header no-img">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-heading">
          <h1>Deep Dream</h1>
		  
		  
		  
		  <span class="post-meta">Posted on April 14, 2020</span>
		  
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class="container">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

      

      <article role="main" class="blog-post">
        <p>Deep Dream is a computer vision program, developed by Google engineer Alexander Mordvintsev that turns simple images into dream-like psychedelic image. The program uses CNNs behind the scenes to make this happen. This post discusses about this algorithm and its implementation.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e1/Tie-dye.png" alt="Psychedelic Images" /></p>

<p><em>Let’s get high!</em></p>

<h2 id="deep-dream-algorithm">Deep Dream Algorithm</h2>
<p>Convolutional Neural Networks trained on classification of tasks, are designed to detect faces and patterns in images. However, once trained, the network can also be used to do the reverse task, and adjust the input image slightly to make those patterns appear in the image. After enough reiterations, the network starts to amplify the patterns in the image and gives us really creepy images.</p>

<p>First, some layers of the Neural Network are selected. An image is then passed again and again through the network, while calculating the loss. By means of <strong>gradient ascent</strong>(not gradient descent), we try to amplify the activations resulting from the loss function. These loss images are then added iteratively to the input image. Thus resulting in images with amplified features.</p>

<p><img src="https://miro.medium.com/max/1656/1*uW81y16b-ptBDV8SIT1beQ.png" alt="Inception Network" /></p>

<p><em>Incpetion Neural Network we are going to use</em></p>

<p>Apart from recreational purposes, the algorithm can be used to study the layers of the Neural Networks, as to which classification task they are performing.</p>

<p>Let’s focus on its implementation</p>

<p><img src="https://i.gifer.com/S5u.gif" alt="Let's go deep" /></p>

<p><em>Let’s go deep</em></p>

<h2 id="initialization">Initialization</h2>
<p>In order to get started with the program, we need a CNN trained on detection tasks. Inception5h model will be the one used for this purpose. Inception is an object detection CNN developed by Google.</p>

<h3 id="downloading-the-network">Downloading the Network</h3>
<p>First of all we will download the weights and configuration of the network.</p>

<p>Define the directory names</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Internet URL for the tar-file with the Inception Model</span>
<span class="n">data_url</span> <span class="o">=</span> <span class="s">"http://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip"</span>

<span class="c"># Directory to store the downloaded data</span>
<span class="n">data_dir</span> <span class="o">=</span> <span class="s">"inception/5h/"</span>

<span class="c"># File containing the Tensorflow graph definition(Will be downloaded in inception/5h)</span>
<span class="n">path_graph_def</span> <span class="o">=</span> <span class="s">"tensorflow_inception_graph.pb"</span>
</code></pre></div></div>

<p>Download and extract</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Download the file from the internet</span>
<span class="n">file_path</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">data_url</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">data_dir</span><span class="p">)</span>

<span class="c"># Unpack the zip file</span>
<span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'r'</span><span class="p">)</span><span class="o">.</span><span class="n">extractall</span><span class="p">(</span><span class="n">data_dir</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="working-with-inception">Working with Inception</h3>
<p>The unzipped file contains proto-buf configuration files, which are to be loaded into our code</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Inception5h</span><span class="p">:</span>
  <span class="s">"""
  The Inception model is a Deep Neural Network which has already been
  trained for classifying images into 1000 different categories.

  When you create a new instance of this class, the Inception model
  will be loaded and can be used immediately without training
  """</span>

  <span class="c"># Name of the tensor for feeding the input image</span>
  <span class="n">tensor_name_input_image</span> <span class="o">=</span> <span class="s">"input:0"</span>

  <span class="c"># Names for some of the commonly used layers in the Inception model</span>
  <span class="n">layer_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">'conv2d0'</span><span class="p">,</span> <span class="s">'conv2d1'</span><span class="p">,</span> <span class="s">'conv2d2'</span><span class="p">,</span>
                 <span class="s">'mixed3a'</span><span class="p">,</span> <span class="s">'mixed3b'</span><span class="p">,</span>
                 <span class="s">'mixed4a'</span><span class="p">,</span> <span class="s">'mixed4b'</span><span class="p">,</span> <span class="s">'mixed4c'</span><span class="p">,</span> <span class="s">'mixed4d'</span><span class="p">,</span> <span class="s">'mixed4e'</span><span class="p">,</span>
                 <span class="s">'mixed5a'</span><span class="p">,</span> <span class="s">'mixed5b'</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c"># Load the inception model from the file.</span>

    <span class="c"># Create a new TensorFlow computational graph</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

    <span class="c"># Set the new graph as the default</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">as_default</span><span class="p">():</span>
      <span class="c"># Tensorflow graphs are saved to disk as proto-bufs</span>
      <span class="c"># which is a file-format that works on multiple platforms.</span>
      <span class="c"># In this case it is saved as a binary file</span>

      <span class="c"># Open the graph-def file for binary reading.</span>
      <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">path_graph_def</span><span class="p">)</span>
      
      <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">gfile</span><span class="o">.</span><span class="n">GFile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
        <span class="c"># The graph-def is a saved copy of a TensorFlow graph.</span>
        <span class="c"># First we need to create an empty graph-def</span>
        <span class="n">graph_def</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">GraphDef</span><span class="p">()</span>

        <span class="c"># Then we load the prot-buf file into the graph-def</span>
        <span class="n">graph_def</span><span class="o">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

        <span class="c"># Finally we import the graph-def to the default Tensorflow graph</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">import_graph_def</span><span class="p">(</span><span class="n">graph_def</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>

        <span class="c"># Now self.graph holds the Inception model from the proto-buf file</span>
      
      <span class="c"># Get a reference to the tensor for inputting the images to the graph</span>
      <span class="bp">self</span><span class="o">.</span><span class="nb">input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">get_tensor_by_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor_name_input_image</span><span class="p">)</span>

      <span class="c"># Get references to the tensors for the commonly used layers</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">layer_tensors</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">get_tensor_by_name</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">":0"</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer_names</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">create_feed_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">"""
    Create and return a feed-dict with an image

    image: Input image is a 3-dim array which is already decoded
           The pixels MUST be values between 0 and 255 (float or int)

    return: Dict for feeding to the Inception graph in TensorFlow 
    """</span>

    <span class="c"># Expand 3-dim array to 4-dim by prepending an 'empty' dimension.</span>
    <span class="c"># This is because we are only feeding a single image, but the</span>
    <span class="c"># Inception model was built to take multiple images as input</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c"># Image is passed in as a 3-dim array of raw pixel-values.</span>
    <span class="n">feed_dict</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor_name_input_image</span><span class="p">:</span> <span class="n">image</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">feed_dict</span>

  <span class="k">def</span> <span class="nf">get_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensor</span><span class="p">):</span>
    <span class="s">"""
    Get the gradient of the given tensor with respect to
    the input image. This allows us to modify the input
    image so as to maximize the given tensor.
    (For use in DeepDream and Visual Analysis)

    tensor: Tensor whose value we want to maximize
    return: Gradient for the tensor with regard to the input image
    """</span>

    <span class="c"># Set the graph as default so we can add operations to it</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">as_default</span><span class="p">():</span>
      <span class="c"># Square the tensor-values</span>
      <span class="n">tensor</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>

      <span class="c"># Average the tensor so we get a single scalar value</span>
      <span class="n">tensor_mean</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>

      <span class="c"># Use Tensorflow to automatically create a mathematically</span>
      <span class="c"># formula for the gradient using the chain-rule</span>
      <span class="n">gradient</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gradients</span><span class="p">(</span><span class="n">tensor_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="nb">input</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">gradient</span>
</code></pre></div></div>

<h3 id="using-the-model">Using the Model</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">model</span> <span class="o">=</span> <span class="n">Inception5h</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="the-algorithm">The Algorithm</h2>
<p>Now, let’s code the functions that are actually going to be used in the algorithm.</p>

<h3 id="gradient">Gradient</h3>
<p>This function will calculate the gradient of an input image. The Inception model can accept images of any size, but very large images may use many GBs of RAM. In order to keep the RAM usage low, we will split the input image into smaller tiles and calculate the gradient for each of the tiles.</p>

<p>However, this may result in visible lines in the final images produced by the algorithm. We therefore choose the tiles randomly so the locations of the tiles are always different. This makes the seams between the lines invisible in the final image.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Function to determine an appropriate tile-size</span>
<span class="c"># Tile size depends on image-dimensions</span>
<span class="k">def</span> <span class="nf">get_tile_size</span><span class="p">(</span><span class="n">num_pixels</span><span class="p">,</span> <span class="n">tile_size</span><span class="o">=</span><span class="mi">400</span><span class="p">):</span>
  <span class="s">"""
  num_pixels: number of pixels in dimension of the image
  tile_size: desired tile_size
  """</span>

  <span class="c"># How many times can we repeat a tile of the desired size</span>
  <span class="n">num_tiles</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">num_pixels</span> <span class="o">/</span> <span class="n">tile_size</span><span class="p">))</span>

  <span class="c"># Ensure that there is at least 1 tile</span>
  <span class="n">num_tiles</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_tiles</span><span class="p">)</span>

  <span class="c"># The actual tile size</span>
  <span class="n">actual_tile_size</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_pixels</span> <span class="o">/</span> <span class="n">num_tiles</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">actual_tile_size</span>

<span class="c"># Function to compute gradient for an input image</span>
<span class="c"># The image is split into tiles and gradient calculated for each tile</span>
<span class="c"># The tiles are chosen randomly to avoid visibile seems</span>
<span class="k">def</span> <span class="nf">tiled_gradient</span><span class="p">(</span><span class="n">gradient</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">tile_size</span><span class="o">=</span><span class="mi">400</span><span class="p">):</span>
  <span class="c"># Allocate an array for the gradient of the entire image</span>
  <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

  <span class="c"># Number of pixels for the x and y axes</span>
  <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>

  <span class="c"># Tile size for the x axis</span>
  <span class="n">x_tile_size</span> <span class="o">=</span> <span class="n">get_tile_size</span><span class="p">(</span><span class="n">num_pixels</span><span class="o">=</span><span class="n">x_max</span><span class="p">,</span> <span class="n">tile_size</span><span class="o">=</span><span class="n">tile_size</span><span class="p">)</span>
  <span class="c"># 1/4 of the tile size</span>
  <span class="n">x_tile_size4</span> <span class="o">=</span> <span class="n">x_tile_size</span> <span class="o">//</span> <span class="mi">4</span>

  <span class="c"># Tile size for the y axis</span>
  <span class="n">y_tile_size</span> <span class="o">=</span> <span class="n">get_tile_size</span><span class="p">(</span><span class="n">num_pixels</span><span class="o">=</span><span class="n">y_max</span><span class="p">,</span> <span class="n">tile_size</span><span class="o">=</span><span class="n">tile_size</span><span class="p">)</span>
  <span class="c"># 1/4 of the tile size</span>
  <span class="n">y_tile_size4</span> <span class="o">=</span> <span class="n">y_tile_size</span> <span class="o">//</span> <span class="mi">4</span>

  <span class="c"># Random start position for the tiles on the x axis</span>
  <span class="c"># The random value is between -3/4 and -1/4 of the tile-size</span>
  <span class="c"># This is so the border tiles are at least 1/4 of the tile size</span>
  <span class="c"># otherwise the tiles may be too small which creates noisy gradient</span>
  <span class="n">x_start</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">x_tile_size4</span><span class="p">,</span> <span class="o">-</span><span class="n">x_tile_size4</span><span class="p">)</span>

  <span class="k">while</span> <span class="n">x_start</span> <span class="o">&lt;</span> <span class="n">x_max</span><span class="p">:</span>
    <span class="c"># End position for the current tile</span>
    <span class="n">x_end</span> <span class="o">=</span> <span class="n">x_start</span> <span class="o">+</span> <span class="n">x_tile_size</span>

    <span class="c"># Ensure the tile's start and end positions are valid</span>
    <span class="n">x_start_lim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x_end_lim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_end</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>

    <span class="c"># Random start position for the tiles on the y axis</span>
    <span class="c"># The random value is between -3/4 and -1/4 of the tile size</span>
    <span class="n">y_start</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">y_tile_size4</span><span class="p">,</span> <span class="n">y_tile_size4</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">y_start</span> <span class="o">&lt;</span> <span class="n">y_max</span><span class="p">:</span>
      <span class="c"># End position for the current tile</span>
      <span class="n">y_end</span> <span class="o">=</span> <span class="n">y_start</span> <span class="o">+</span> <span class="n">y_tile_size</span>

      <span class="c"># Ensure the tiles start and end positions are valid</span>
      <span class="n">y_start_lim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">y_end_lim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_end</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>

      <span class="c"># Get the image tile</span>
      <span class="n">img_tile</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">x_start_lim</span><span class="p">:</span><span class="n">x_end_lim</span><span class="p">,</span> <span class="n">y_start_lim</span><span class="p">:</span><span class="n">y_end_lim</span><span class="p">,</span> <span class="p">:]</span>

      <span class="c"># Create a feed dict with the image tile</span>
      <span class="n">feed_dict</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">create_feed_dict</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">img_tile</span><span class="p">)</span>

      <span class="c"># Use TensorFlow to calculate the gradient value</span>
      <span class="n">g</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">gradient</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="n">feed_dict</span><span class="p">)</span>

      <span class="c"># Normalize the gradient for the tile. This is</span>
      <span class="c"># necessary because the tiles may have very different</span>
      <span class="c"># values. Normalizing gives a more coherent gradient</span>
      <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>

      <span class="c"># Store the tile's gradient at the appropriate location</span>
      <span class="n">grad</span><span class="p">[</span><span class="n">x_start_lim</span><span class="p">:</span><span class="n">x_end_lim</span><span class="p">,</span> <span class="n">y_start_lim</span><span class="p">:</span><span class="n">y_end_lim</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">g</span>

      <span class="c"># Advance the start position for the y axis</span>
      <span class="n">y_start</span> <span class="o">=</span> <span class="n">y_end</span>

    <span class="c"># Advance the start position for x axis</span>
    <span class="n">x_start</span> <span class="o">=</span> <span class="n">x_end</span>

  <span class="k">return</span> <span class="n">grad</span>
</code></pre></div></div>

<h3 id="image-optimization">Image Optimization</h3>
<p>The optimization loop for the algorithm. It calculates the gradient of the given layer of the Inception model with regard to the input image. The gradient is then added to the input image so the mean value of the tensor is increased. This process is repeated a number of times and amplifies the pattherns the Inception model sees in the input image.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Function to optimize an image</span>
<span class="c"># Maximizes the mean value of the given layer_tensor</span>
<span class="c"># Using gradient ascent</span>
<span class="k">def</span> <span class="nf">optimize_image</span><span class="p">(</span><span class="n">layer_tensor</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">num_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">tile_size</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">show_gradient</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
  <span class="s">"""
  layer_tensor: Reference to a tensor that will be maximized
  image: Input image to be used as starting point
  num_iterations: Number of optimization iterations to perform
  step_size: Scale for each step of the gradient ascent
  tile_size: Size of the tiles when calculating the gradient
  show_gradient: Plot the gradient in each iteration
  """</span>

  <span class="c"># Copy the image so we don't overwrite the original image</span>
  <span class="n">img</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

  <span class="k">print</span><span class="p">(</span><span class="s">"Image before:"</span><span class="p">)</span>
  <span class="n">plot_image</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

  <span class="k">print</span><span class="p">(</span><span class="s">"Processing image: "</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">""</span><span class="p">)</span>

  <span class="c"># Use TensorFlow to get the mathematical function for the</span>
  <span class="c"># gradient of the given layer tensor with regard to the</span>
  <span class="c"># input image. This may cause TensorFlow to add the same</span>
  <span class="c"># math-expressions to the graph each time this function is called</span>
  <span class="c"># It may use a lot of RAM and could be moved outside the function</span>
  <span class="n">gradient</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_gradient</span><span class="p">(</span><span class="n">layer_tensor</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">):</span>
    <span class="c"># Calculate the value of the gradient</span>
    <span class="c"># This tells us how to change the image so as to</span>
    <span class="c"># maximize the mean of the given layer-tensor</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">tiled_gradient</span><span class="p">(</span><span class="n">gradient</span><span class="o">=</span><span class="n">gradient</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">img</span><span class="p">)</span>

    <span class="c"># Blur the gradient with different amounts and add</span>
    <span class="c"># them together. The blur amount is also increased</span>
    <span class="c"># during the optimization. This was found to give</span>
    <span class="c"># nice, smooth images. The blur-amount is called</span>
    <span class="c"># sigma (0=no blur, 1 = low blur, etc.) We could</span>
    <span class="c"># call gaussian_filter(grad, sigma=(sigma, sigma, 0.0))</span>
    <span class="c"># which would not blur the color channel. This tends to</span>
    <span class="c"># give psychadelic / pastel colors in the resulting images</span>
    <span class="c"># When the color channel is also blurred the colors of the</span>
    <span class="c"># input image are mostly retained in the output image</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">4.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_iterations</span> <span class="o">+</span> <span class="mf">0.5</span>
    <span class="n">grad_smooth1</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">grad_smooth2</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">grad_smooth3</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="p">(</span><span class="n">grad_smooth1</span> <span class="o">+</span> <span class="n">grad_smooth2</span> <span class="o">+</span> <span class="n">grad_smooth3</span><span class="p">)</span>

    <span class="c"># Scale the step-size according to the gradient-values</span>
    <span class="c"># This may not be necessary because the tiled-gradient</span>
    <span class="c"># is already normalized</span>
    <span class="n">step_size_scaled</span> <span class="o">=</span> <span class="n">step_size</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>

    <span class="c"># Update the image by following the gradient</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span> <span class="o">+</span> <span class="n">grad</span> <span class="o">*</span> <span class="n">step_size_scaled</span>
    <span class="c"># Let's try this then!</span>
    <span class="c"># img = img - grad * step_size_scaled</span>

    <span class="k">if</span> <span class="n">show_gradient</span><span class="p">:</span>
      <span class="c"># Print statistics for the gradient</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s">"Gradient min: {0:&gt;9.6f}, max: {1:&gt;9.6f}, stepsize: {2:&gt;9.2f}"</span>
      <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="nb">min</span><span class="p">(),</span> <span class="n">grad</span><span class="o">.</span><span class="nb">max</span><span class="p">(),</span> <span class="n">step_size_scaled</span><span class="p">))</span>

      <span class="c"># Plot the gradient</span>
      <span class="n">plot_gradient</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="c"># Otherwise show a little progress indicator</span>
      <span class="k">print</span><span class="p">(</span><span class="s">"."</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">""</span><span class="p">)</span>
  
  <span class="k">print</span><span class="p">()</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Image after:"</span><span class="p">)</span>
  <span class="n">plot_image</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">img</span>
</code></pre></div></div>

<h3 id="recursive-optimization">Recursive Optimization</h3>
<p>Function to downscale the input image several times recursively. This will result in larger patterns in the final image, and speed up computation as well!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">recursive_optimize</span><span class="p">(</span><span class="n">layer_tensor</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">num_repeats</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">rescale_factor</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">blend</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">num_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">tile_size</span><span class="o">=</span><span class="mi">400</span><span class="p">):</span>
  <span class="s">"""
  Recursively blur and downscale the input image
  Each downscaled image is run through the optimize_image()
  function to amplify the patterns that the Inception model sees

  image: Input image
  rescale_factor: Downscaling factor for the image
  num_iterations: Number of optimization iterations to perform
  step_size: Scale for each step of the gradient ascent
  tile_size: Size of the tiles when calculating the gradient
  """</span>

  <span class="c"># Recursion</span>
  <span class="k">if</span> <span class="n">num_repeats</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c"># Blur the image to prevent artifacts when downscaling</span>
    <span class="c"># The blur amount is controlled by sigma. Note that the</span>
    <span class="c"># color channel is not blurred as it would make the image gray</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">img_blur</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>

    <span class="c"># Downscale the image</span>
    <span class="n">img_downscaled</span> <span class="o">=</span> <span class="n">resize_image</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">img_blur</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="n">rescale_factor</span><span class="p">)</span>

    <span class="c"># Recursive call to this function</span>
    <span class="c"># While subtracting num_repeats</span>
    <span class="n">img_result</span> <span class="o">=</span> <span class="n">recursive_optimize</span><span class="p">(</span><span class="n">layer_tensor</span><span class="o">=</span><span class="n">layer_tensor</span><span class="p">,</span>
                                    <span class="n">image</span><span class="o">=</span><span class="n">img_downscaled</span><span class="p">,</span>
                                    <span class="n">num_repeats</span><span class="o">=</span><span class="n">num_repeats</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">rescale_factor</span><span class="o">=</span><span class="n">rescale_factor</span><span class="p">,</span>
                                    <span class="n">blend</span><span class="o">=</span><span class="n">blend</span><span class="p">,</span>
                                    <span class="n">num_iterations</span><span class="o">=</span><span class="n">num_iterations</span><span class="p">,</span>
                                    <span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span>
                                    <span class="n">tile_size</span><span class="o">=</span><span class="n">tile_size</span><span class="p">)</span>
    
    <span class="c"># Upscale the resulting image back to its original size</span>
    <span class="n">img_upscaled</span> <span class="o">=</span> <span class="n">resize_image</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">img_result</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c"># Blend the original and processed images</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">blend</span> <span class="o">*</span> <span class="n">image</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">blend</span><span class="p">)</span> <span class="o">*</span> <span class="n">img_upscaled</span>

  <span class="k">print</span><span class="p">(</span><span class="s">"Recursive level:"</span><span class="p">,</span> <span class="n">num_repeats</span><span class="p">)</span>

  <span class="c"># Process the image using DeepDream algorithm</span>
  <span class="n">img_result</span> <span class="o">=</span> <span class="n">optimize_image</span><span class="p">(</span><span class="n">layer_tensor</span><span class="o">=</span><span class="n">layer_tensor</span><span class="p">,</span>
                              <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">,</span>
                              <span class="n">num_iterations</span><span class="o">=</span><span class="n">num_iterations</span><span class="p">,</span>
                              <span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span>
                              <span class="n">tile_size</span><span class="o">=</span><span class="n">tile_size</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">img_result</span> 
</code></pre></div></div>

<h2 id="running-the-algorithm">Running the algorithm</h2>

<h3 id="tensorflow-session">TensorFlow Session</h3>
<p>Execute an interactive tensorflow session</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">session</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">InteractiveSession</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="execute-the-algorithm">Execute the Algorithm</h3>
<p>Let’s select a random layer tensor and execute the algorithm</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">image</span> <span class="o">=</span> <span class="n">load_image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">'images/scene.jpg'</span><span class="p">)</span>

<span class="n">layer_tensor</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">layer_tensors</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

<span class="n">img_result_1</span> <span class="o">=</span> <span class="n">optimize_image</span><span class="p">(</span><span class="n">layer_tensor</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">num_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">6.0</span><span class="p">,</span> <span class="n">tile_size</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>

<span class="n">img_result_2</span> <span class="o">=</span> <span class="n">recursive_optimize</span><span class="p">(</span><span class="n">layer_tensor</span><span class="o">=</span><span class="n">layer_tensor</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">num_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">rescale_factor</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">num_repeats</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">blend</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="results">Results</h3>

<p><img src="https://c402277.ssl.cf1.rackcdn.com/photos/12848/images/blog_media_carousel/Bison.jpg?1480606347" alt="Input Image" /></p>

<p><em>The input image</em></p>

<p><img src="./../assets/img_result_1.png" alt="img_result_1" /></p>

<p><em>img_result_1</em></p>

<p><img src="./../assets/img_result_2.png" alt="img_result_2" /></p>

<p><em>img_result_2</em></p>

<p>As can be seen <code class="highlighter-rouge">img_result_1</code> has a lot of high frequency content, compared to <code class="highlighter-rouge">img_result_2</code></p>

<h3 id="analyzing-the-layer">Analyzing the Layer</h3>
<p>We have an activation function that gets our feature maps</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Function to classify a single image</span>
<span class="k">def</span> <span class="nf">activations</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
  <span class="s">"""
  image_path: The input image is a jpeg-file with this file-path
  image: The input image is a 3-dim array which is already decoded
         The pixels must be uint8 format

  return: Array of floats(softmax array) indicating how likely
          the Inception model thinks the image is of each given class
  """</span>

  <span class="c"># Create a feed-dict for the TensorFlow graph with the input image</span>
  <span class="n">feed_dict</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">create_feed_dict</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

  <span class="c"># Execute the TensorFlow session to get the predicted labels</span>
  <span class="n">pred</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="n">feed_dict</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">pred</span>
</code></pre></div></div>

<p>Since we got a lot eyes and fur in the final image, the layers in our network ought to detect these features. Let’s observe some of the feature maps based on a cat image.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cat_image</span> <span class="o">=</span> <span class="n">load_image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">'images/cats.jpeg'</span><span class="p">)</span>

<span class="n">layer_name</span> <span class="o">=</span> <span class="s">'mixed3b:0'</span>	<span class="c"># This is the name of the layer we selected above</span>

<span class="n">activate</span> <span class="o">=</span> <span class="n">activations</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="n">cat_image</span><span class="p">)</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>		<span class="c">#i can be 0, 1, 2 ... number of feature maps for a given layer</span>
<span class="n">plt</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">activate</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s">'virdis'</span><span class="p">)</span>
</code></pre></div></div>

<p>Following are the feature maps we get. They show the feature activations we get for the input image.</p>

<p><img src="https://a57.foxnews.com/media2.foxnews.com/BrightCove/694940094001/2019/04/05/931/524/694940094001_6022906316001_6022911719001-vs.jpg?ve=1&amp;tl=1" alt="Cat Image" /></p>

<p><em>The Cat Image</em></p>

<p><img src="./../assets/feature_maps.png" alt="Feature Maps" /></p>

<p><em>Feature Maps for i=1, 2 and 5</em></p>


      </article>

      

      
        <!-- Check if any share-links are active -->




<section id = "social-share-section">
  <span class="sr-only">Share: </span>

  
  <!--- Share on Twitter -->
    <a href="https://twitter.com/intent/tweet?text=Deep+Dream+http://localhost:4000/2020-04-14-deep-dream/"
      class="btn btn-social-icon btn-twitter" title="Share on Twitter">
      <span class="fa fa-fw fa-twitter" aria-hidden="true"></span>
      <span class="sr-only">Twitter</span>
    </a>
  

  
  <!--- Share on Facebook -->
    <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/2020-04-14-deep-dream/"
      class="btn btn-social-icon btn-facebook" title="Share on Facebook">
      <span class="fa fa-fw fa-facebook" aria-hidden="true"></span>
      <span class="sr-only">Facebook</span>
    </a>
  

  

  
  <!--- Share on LinkedIn -->
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/2020-04-14-deep-dream/"
      class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn">
      <span class="fa fa-fw fa-linkedin" aria-hidden="true"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  

</section>



      

      <ul class="pager blog-pager">
        
        <li class="previous">
          <a href="/colab-Sakshay_Mahna/2020-04-07-convolutional-neural-network/" data-toggle="tooltip" data-placement="top" title="Convolutional Neural Network">&larr; Previous Post</a>
        </li>
        
        
      </ul>

      
        <div class="disqus-comments">
          
        </div>
          
        <div class="staticman-comments">
          

        </div>
        <div class="justcomments-comments">
          
        </div>
      
    </div>
  </div>
</div>


    <footer>
  <div class="container beautiful-jekyll-footer">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links"><li><a href="/colab-Sakshay_Mahna/feed.xml" title="RSS"><span class="fa-stack fa-lg" aria-hidden="true">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                </span>
                <span class="sr-only">RSS</span>
              </a>
            </li><li><a href="mailto:sakshum19@gmail.com" title="Email me"><span class="fa-stack fa-lg" aria-hidden="true">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                </span>
                <span class="sr-only">Email me</span>
              </a>
            </li><li><a href="https://github.com/SakshayMahna" title="GitHub"><span class="fa-stack fa-lg" aria-hidden="true">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
                <span class="sr-only">GitHub</span>
              </a>
            </li><li><a href="https://twitter.com/MahnaSakshay" title="Twitter"><span class="fa-stack fa-lg" aria-hidden="true">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                </span>
                <span class="sr-only">Twitter</span>
              </a>
            </li><li><a href="https://linkedin.com/in/sakshaymahna" title="LinkedIn"><span class="fa-stack fa-lg" aria-hidden="true">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                </span>
                <span class="sr-only">LinkedIn</span>
              </a>
            </li></ul>
      <p class="copyright text-muted">
      Sakshay Mahna
      &nbsp;&bull;&nbsp;
      2020

      

      
      </p>
          <!-- Please don't remove this, keep my open source work credited :) -->
    <p class="theme-by text-muted">
      Theme by
      <a href="https://deanattali.com/beautiful-jekyll/">beautiful-jekyll</a>
    </p>
      </div>
    </div>
  </div>
</footer>

  
    






  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script>
      	if (typeof jQuery == 'undefined') {
      	  document.write('<script src="/colab-Sakshay_Mahna/js/jquery-1.11.2.min.js"></scr' + 'ipt>');
      	}
      </script>
    
  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
	<script src="/colab-Sakshay_Mahna/js/bootstrap.min.js"></script>
    
  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
	<script src="/colab-Sakshay_Mahna/js/main.js"></script>
    
  


  
  </body>
</html>
